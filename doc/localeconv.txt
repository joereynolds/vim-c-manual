*localeconv.txt*
*localeconv*

7.11.2.1 The localeconv function

==============================================================================
Synopsis
1

#include <locale.h>
struct lconv *localeconv(void);

==============================================================================
Description

2

The localeconv function sets the components of an object with type struct lconv
with values appropriate for the formatting of numeric quantities (monetary and otherwise)
according to the rules of the current locale.

225) The implementation shall arrange to encode in a string the various categories due to a heterogeneous
locale when category has the value LC_ALL.

§7.11.2.1

Library

225

ISO/IEC 9899:201x

3


N1570

The members of the structure with type char * are pointers to strings, any of which
(except decimal_point) can point to "", to indicate that the value is not available in
the current locale or is of zero length. Apart from grouping and mon_grouping, the
strings shall start and end in the initial shift state. The members with type char are
nonnegative numbers, any of which can be CHAR_MAX to indicate that the value is not
available in the current locale. The members include the following:
char *decimal_point
The decimal-point character used to format nonmonetary quantities.
char *thousands_sep
The character used to separate groups of digits before the decimal-point
character in formatted nonmonetary quantities.
char *grouping
A string whose elements indicate the size of each group of digits in
formatted nonmonetary quantities.
char *mon_decimal_point
The decimal-point used to format monetary quantities.
char *mon_thousands_sep
The separator for groups of digits before the decimal-point in formatted
monetary quantities.
char *mon_grouping
A string whose elements indicate the size of each group of digits in
formatted monetary quantities.
char *positive_sign
The string used to indicate a nonnegative-valued formatted monetary
quantity.
char *negative_sign
The string used to indicate a negative-valued formatted monetary quantity.
char *currency_symbol
The local currency symbol applicable to the current locale.
char frac_digits
The number of fractional digits (those after the decimal-point) to be
displayed in a locally formatted monetary quantity.
char p_cs_precedes
Set to 1 or 0 if the currency_symbol respectively precedes or
succeeds the value for a nonnegative locally formatted monetary quantity.

226

Library

§7.11.2.1

N1570



char n_cs_precedes
Set to 1 or 0 if the currency_symbol respectively precedes or
succeeds the value for a negative locally formatted monetary quantity.
char p_sep_by_space
Set to a value indicating the separation of the currency_symbol, the
sign string, and the value for a nonnegative locally formatted monetary
quantity.
char n_sep_by_space
Set to a value indicating the separation of the currency_symbol, the
sign string, and the value for a negative locally formatted monetary
quantity.
char p_sign_posn
Set to a value indicating the positioning of the positive_sign for a
nonnegative locally formatted monetary quantity.
char n_sign_posn
Set to a value indicating the positioning of the negative_sign for a
negative locally formatted monetary quantity.
char *int_curr_symbol
The international currency symbol applicable to the current locale. The
first three characters contain the alphabetic international currency symbol
in accordance with those specified in ISO 4217. The fourth character
(immediately preceding the null character) is the character used to separate
the international currency symbol from the monetary quantity.
char int_frac_digits
The number of fractional digits (those after the decimal-point) to be
displayed in an internationally formatted monetary quantity.
char int_p_cs_precedes
Set to 1 or 0 if the int_curr_symbol respectively precedes or
succeeds the value for a nonnegative internationally formatted monetary
quantity.
char int_n_cs_precedes
Set to 1 or 0 if the int_curr_symbol respectively precedes or
succeeds the value for a negative internationally formatted monetary
quantity.
char int_p_sep_by_space
Set to a value indicating the separation of the int_curr_symbol, the
sign string, and the value for a nonnegative internationally formatted
monetary quantity.
§7.11.2.1
Library
227

ISO/IEC 9899:201x


N1570

char int_n_sep_by_space
Set to a value indicating the separation of the int_curr_symbol, the
sign string, and the value for a negative internationally formatted monetary
quantity.
char int_p_sign_posn
Set to a value indicating the positioning of the positive_sign for a
nonnegative internationally formatted monetary quantity.
char int_n_sign_posn
Set to a value indicating the positioning of the negative_sign for a
negative internationally formatted monetary quantity.
4

5

The elements of grouping and mon_grouping are interpreted according to the
following:
CHAR_MAX

No further grouping is to be performed.

0

The previous element is to be repeatedly used for the remainder of the
digits.

other

The integer value is the number of digits that compose the current group.
The next element is examined to determine the size of the next group of
digits before the current group.

The values of p_sep_by_space, n_sep_by_space, int_p_sep_by_space,
and int_n_sep_by_space are interpreted according to the following:
0

No space separates the currency symbol and value.

1

If the currency symbol and sign string are adjacent, a space separates them from the
value; otherwise, a space separates the currency symbol from the value.

If the currency symbol and sign string are adjacent, a space separates them;
otherwise, a space separates the sign string from the value.
For int_p_sep_by_space and int_n_sep_by_space, the fourth character of
int_curr_symbol is used instead of a space.
2

6

The values of p_sign_posn, n_sign_posn, int_p_sign_posn,
int_n_sign_posn are interpreted according to the following:
0

Parentheses surround the quantity and currency symbol.

1

The sign string precedes the quantity and currency symbol.

2

The sign string succeeds the quantity and currency symbol.

3

The sign string immediately precedes the currency symbol.

4

The sign string immediately succeeds the currency symbol.

228

Library

and

§7.11.2.1

N1570

7



The implementation shall behave as if no library function calls the localeconv
function.

==============================================================================
Returns

8

The localeconv function returns a pointer to the filled-in object. The structure
pointed to by the return value shall not be modified by the program, but may be
overwritten by a subsequent call to the localeconv function. In addition, calls to the
setlocale function with categories LC_ALL, LC_MONETARY, or LC_NUMERIC may
overwrite the contents of the structure.

9

EXAMPLE 1 The following table illustrates rules which may well be used by four countries to format
monetary quantities.
Local format

10

International format

Country

Positive

Negative

Positive

Country1
Country2
Country3
Country4

1.234,56 mk
L.1.234
ƒ 1.234,56
SFrs.1,234.56

-1.234,56 mk
-L.1.234
ƒ -1.234,56
SFrs.1,234.56C

FIM
ITL
NLG
CHF

1.234,56
1.234
1.234,56
1,234.56

Negative
FIM -1.234,56
-ITL 1.234
NLG -1.234,56
CHF 1,234.56C

For these four countries, the respective values for the monetary members of the structure returned by
localeconv could be:

mon_decimal_point
mon_thousands_sep
mon_grouping
positive_sign
negative_sign
currency_symbol
frac_digits
p_cs_precedes
n_cs_precedes
p_sep_by_space
n_sep_by_space
p_sign_posn
n_sign_posn
int_curr_symbol
int_frac_digits
int_p_cs_precedes
int_n_cs_precedes
int_p_sep_by_space
int_n_sep_by_space
int_p_sign_posn
int_n_sign_posn

§7.11.2.1

Country1

Country2

Country3

Country4

","
"."
"\3"
""
"-"
"mk"
2
0
0
1
1
1
1
"FIM "
2
1
1
1
2
1
4

""
"."
"\3"
""
"-"
"L."
0
1
1
0
0
1
1
"ITL "
0
1
1
1
1
1
1

","
"."
"\3"
""
"-"
"\u0192"
2
1
1
1
2
1
4
"NLG "
2
1
1
1
2
1
4

"."
","
"\3"
""
"C"
"SFrs."
2
1
1
0
0
1
2
"CHF "
2
1
1
1
1
1
2

Library

229

ISO/IEC 9899:201x

11


N1570

EXAMPLE 2 The following table illustrates how the cs_precedes, sep_by_space, and sign_posn members
affect the formatted value.
p_sep_by_space
p_cs_precedes

p_sign_posn

0

1

230

0

1

2

0
1
2
3
4

(1.25$)
+1.25$
1.25$+
1.25+$
1.25$+

(1.25 $)
+1.25 $
1.25 $+
1.25 +$
1.25 $+

(1.25$)
+ 1.25$
1.25$ +
1.25+ $
1.25$ +

0
1
2
3
4

($1.25)
+$1.25
$1.25+
+$1.25
$+1.25

($ 1.25)
+$ 1.25
$ 1.25+
+$ 1.25
$+ 1.25

($1.25)
+ $1.25
$1.25 +
+ $1.25
$ +1.25

Library

§7.11.2.1

N1570



7.12 Mathematics <math.h>
1

The header <math.h> declares two types and many mathematical functions and defines
several macros. Most synopses specify a family of functions consisting of a principal
function with one or more double parameters, a double return value, or both; and
other functions with the same name but with f and l suffixes, which are corresponding
functions with float and long double parameters, return values, or both.226)
Integer arithmetic functions and conversion functions are discussed later.

2

The types
float_t
double_t
are floating types at least as wide as float and double, respectively, and such that
double_t is at least as wide as float_t. If FLT_EVAL_METHOD equals 0,
float_t and double_t are float and double, respectively; if
FLT_EVAL_METHOD equals 1, they are both double; if FLT_EVAL_METHOD equals
2, they are both long double; and for other values of FLT_EVAL_METHOD, they are
otherwise implementation-defined.227)

3

The macro
HUGE_VAL
expands to a positive double constant expression, not necessarily representable as a
float. The macros
HUGE_VALF
HUGE_VALL
are respectively float and long double analogs of HUGE_VAL.228)

4

The macro
INFINITY
expands to a constant expression of type float representing positive or unsigned
infinity, if available; else to a positive constant of type float that overflows at

226) Particularly on systems with wide expression evaluation, a <math.h> function might pass arguments
and return values in wider format than the synopsis prototype indicates.
227) The types float_t and double_t are intended to be the implementation’s most efficient types at
least as wide as float and double, respectively. For FLT_EVAL_METHOD equal 0, 1, or 2, the
type float_t is the narrowest type used by the implementation to evaluate floating expressions.
228) HUGE_VAL, HUGE_VALF, and HUGE_VALL can be positive infinities in an implementation that
supports infinities.

§7.12

Library

231

ISO/IEC 9899:201x


N1570

translation time.229)
5

The macro
NAN
is defined if and only if the implementation supports quiet NaNs for the float type. It
expands to a constant expression of type float representing a quiet NaN.

6

The number classification macros
FP_INFINITE
FP_NAN
FP_NORMAL
FP_SUBNORMAL
FP_ZERO
represent the mutually exclusive kinds of floating-point values. They expand to integer
constant expressions with distinct values. Additional implementation-defined floatingpoint classifications, with macro definitions beginning with FP_ and an uppercase letter,
may also be specified by the implementation.

7

The macro
FP_FAST_FMA
is optionally defined. If defined, it indicates that the fma function generally executes
about as fast as, or faster than, a multiply and an add of double operands.230) The
macros
FP_FAST_FMAF
FP_FAST_FMAL
are, respectively, float and long double analogs of FP_FAST_FMA. If defined,
these macros expand to the integer constant 1.

8

The macros
FP_ILOGB0
FP_ILOGBNAN
expand to integer constant expressions whose values are returned by ilogb(x) if x is
zero or NaN, respectively. The value of FP_ILOGB0 shall be either INT_MIN or
-INT_MAX. The value of FP_ILOGBNAN shall be either INT_MAX or INT_MIN.
229) In this case, using INFINITY will violate the constraint in 6.4.4 and thus require a diagnostic.
230) Typically, the FP_FAST_FMA macro is defined if and only if the fma function is implemented
directly with a hardware multiply-add instruction. Software implementations are expected to be
substantially slower.

232

Library

§7.12

N1570

9



The macros
MATH_ERRNO
MATH_ERREXCEPT
expand to the integer constants 1 and 2, respectively; the macro
math_errhandling
expands to an expression that has type int and the value MATH_ERRNO,
MATH_ERREXCEPT, or the bitwise OR of both. The value of math_errhandling is
constant for the duration of the program. It is unspecified whether
math_errhandling is a macro or an identifier with external linkage. If a macro
definition is suppressed or a program defines an identifier with the name
math_errhandling, the behavior is undefined.
If the expression
math_errhandling & MATH_ERREXCEPT can be nonzero, the implementation
shall define the macros FE_DIVBYZERO, FE_INVALID, and FE_OVERFLOW in
<fenv.h>.

7.12.1 Treatment of error conditions
1

The behavior of each of the functions in <math.h> is specified for all representable
values of its input arguments, except where stated otherwise. Each function shall execute
as if it were a single operation without raising SIGFPE and without generating any of the
floating-point exceptions ‘‘invalid’’, ‘‘divide-by-zero’’, or ‘‘overflow’’ except to reflect
the result of the function.

2

For all functions, a domain error occurs if an input argument is outside the domain over
which the mathematical function is defined. The description of each function lists any
required domain errors; an implementation may define additional domain errors, provided
that such errors are consistent with the mathematical definition of the function.231) On a
domain error, the function returns an implementation-defined value; if the integer
expression math_errhandling & MATH_ERRNO is nonzero, the integer expression
errno acquires the value EDOM; if the integer expression math_errhandling &
MATH_ERREXCEPT is nonzero, the ‘‘invalid’’ floating-point exception is raised.

3

Similarly, a pole error (also known as a singularity or infinitary) occurs if the
mathematical function has an exact infinite result as the finite input argument(s) are
approached in the limit (for example, log(0.0)). The description of each function lists
any required pole errors; an implementation may define additional pole errors, provided
that such errors are consistent with the mathematical definition of the function. On a pole
error, the function returns an implementation-defined value; if the integer expression

231) In an implementation that supports infinities, this allows an infinity as an argument to be a domain
error if the mathematical domain of the function does not include the infinity.

§7.12.1

Library

233

ISO/IEC 9899:201x


N1570

math_errhandling & MATH_ERRNO is nonzero, the integer expression errno
acquires the value ERANGE; if the integer expression math_errhandling &
MATH_ERREXCEPT is nonzero, the ‘‘divide-by-zero’’ floating-point exception is raised.
4

Likewise, a range error occurs if the mathematical result of the function cannot be
represented in an object of the specified type, due to extreme magnitude.

5

A floating result overflows if the magnitude of the mathematical result is finite but so
large that the mathematical result cannot be represented without extraordinary roundoff
error in an object of the specified type. If a floating result overflows and default rounding
is in effect, then the function returns the value of the macro HUGE_VAL, HUGE_VALF, or
HUGE_VALL according to the return type, with the same sign as the correct value of the
function; if the integer expression math_errhandling & MATH_ERRNO is nonzero,
the integer expression errno acquires the value ERANGE; if the integer expression
math_errhandling & MATH_ERREXCEPT is nonzero, the ‘‘overflow’’ floatingpoint exception is raised.

6

The result underflows if the magnitude of the mathematical result is so small that the
mathematical result cannot be represented, without extraordinary roundoff error, in an
object of the specified type.232) If the result underflows, the function returns an
implementation-defined value whose magnitude is no greater than the smallest
normalized positive number in the specified type; if the integer expression
math_errhandling & MATH_ERRNO is nonzero, whether errno acquires the
value
ERANGE
is
implementation-defined;
if
the
integer
expression
math_errhandling & MATH_ERREXCEPT is nonzero, whether the ‘‘underflow’’
floating-point exception is raised is implementation-defined.

7

If a domain, pole, or range error occurs and the integer expression
math_errhandling & MATH_ERRNO is zero,233) then errno shall either be set to
the value corresponding to the error or left unmodified. If no such error occurs, errno
shall be left unmodified regardless of the setting of math_errhandling.

232) The term underflow here is intended to encompass both ‘‘gradual underflow’’ as in IEC 60559 and
also ‘‘flush-to-zero’’ underflow.
233) Math errors are being indicated by the floating-point exception flags rather than by errno.

234

Library

§7.12.1

N1570



7.12.2 The FP_CONTRACT pragma

==============================================================================
Synopsis
1

#include <math.h>
#pragma STDC FP_CONTRACT on-off-switch

==============================================================================
Description

2

The FP_CONTRACT pragma can be used to allow (if the state is ‘‘on’’) or disallow (if the
state is ‘‘off’’) the implementation to contract expressions (6.5). Each pragma can occur
either outside external declarations or preceding all explicit declarations and statements
inside a compound statement. When outside external declarations, the pragma takes
effect from its occurrence until another FP_CONTRACT pragma is encountered, or until
the end of the translation unit. When inside a compound statement, the pragma takes
effect from its occurrence until another FP_CONTRACT pragma is encountered
(including within a nested compound statement), or until the end of the compound
statement; at the end of a compound statement the state for the pragma is restored to its
condition just before the compound statement. If this pragma is used in any other
context, the behavior is undefined. The default state (‘‘on’’ or ‘‘off’’) for the pragma is
implementation-defined.

7.12.3 Classification macros
1

In the synopses in this subclause, real-floating indicates that the argument shall be an
expression of real floating type.

7.12.3.1 The fpclassify macro

==============================================================================
Synopsis
1

#include <math.h>
int fpclassify(real-floating x);

==============================================================================
Description

2

The fpclassify macro classifies its argument value as NaN, infinite, normal,
subnormal, zero, or into another implementation-defined category. First, an argument
represented in a format wider than its semantic type is converted to its semantic type.
Then classification is based on the type of the argument.234)

==============================================================================
Returns

3

The fpclassify macro returns the value of the number classification macro
appropriate to the value of its argument.
234) Since an expression can be evaluated with more range and precision than its type has, it is important to
know the type that classification is based on. For example, a normal long double value might
become subnormal when converted to double, and zero when converted to float.

§7.12.3.1

Library

235

ISO/IEC 9899:201x


N1570

7.12.3.2 The isfinite macro

==============================================================================
Synopsis
1

#include <math.h>
int isfinite(real-floating x);

==============================================================================
Description

2

The isfinite macro determines whether its argument has a finite value (zero,
subnormal, or normal, and not infinite or NaN). First, an argument represented in a
format wider than its semantic type is converted to its semantic type. Then determination
is based on the type of the argument.

==============================================================================
Returns

3

The isfinite macro returns a nonzero value if and only if its argument has a finite
value.

7.12.3.3 The isinf macro

==============================================================================
Synopsis
1

#include <math.h>
int isinf(real-floating x);

==============================================================================
Description

2

The isinf macro determines whether its argument value is an infinity (positive or
negative). First, an argument represented in a format wider than its semantic type is
converted to its semantic type. Then determination is based on the type of the argument.

==============================================================================
Returns

3

The isinf macro returns a nonzero value if and only if its argument has an infinite
value.

7.12.3.4 The isnan macro

==============================================================================
Synopsis
1

#include <math.h>
int isnan(real-floating x);

==============================================================================
Description

2

The isnan macro determines whether its argument value is a NaN. First, an argument
represented in a format wider than its semantic type is converted to its semantic type.
Then determination is based on the type of the argument.235)
235) For the isnan macro, the type for determination does not matter unless the implementation supports
NaNs in the evaluation type but not in the semantic type.

236

Library

§7.12.3.4

N1570




==============================================================================
Returns
3

The isnan macro returns a nonzero value if and only if its argument has a NaN value.

7.12.3.5 The isnormal macro

==============================================================================
Synopsis
1

#include <math.h>
int isnormal(real-floating x);

==============================================================================
Description

2

The isnormal macro determines whether its argument value is normal (neither zero,
subnormal, infinite, nor NaN). First, an argument represented in a format wider than its
semantic type is converted to its semantic type. Then determination is based on the type
of the argument.

==============================================================================
Returns

3

The isnormal macro returns a nonzero value if and only if its argument has a normal
value.

7.12.3.6 The signbit macro

==============================================================================
Synopsis
1

#include <math.h>
int signbit(real-floating x);

==============================================================================
Description

2

The signbit macro determines whether the sign of its argument value is negative.236)

==============================================================================
Returns

3

The signbit macro returns a nonzero value if and only if the sign of its argument value
is negative.

236) The signbit macro reports the sign of all values, including infinities, zeros, and NaNs. If zero is
unsigned, it is treated as positive.

§7.12.3.6

Library

237

ISO/IEC 9899:201x


N1570

7.12.4 Trigonometric functions
7.12.4.1 The acos functions

==============================================================================
Synopsis
1

#include <math.h>
double acos(double x);
float acosf(float x);
long double acosl(long double x);

==============================================================================
Description

2

The acos functions compute the principal value of the arc cosine of x. A domain error
occurs for arguments not in the interval [−1, +1].

==============================================================================
Returns

3

The acos functions return arccos x in the interval [0, π ] radians.

7.12.4.2 The asin functions

==============================================================================
Synopsis
1

#include <math.h>
double asin(double x);
float asinf(float x);
long double asinl(long double x);

==============================================================================
Description

2

The asin functions compute the principal value of the arc sine of x. A domain error
occurs for arguments not in the interval [−1, +1].

==============================================================================
Returns

3

The asin functions return arcsin x in the interval [−π /2, +π /2] radians.

7.12.4.3 The atan functions

==============================================================================
Synopsis
1

#include <math.h>
double atan(double x);
float atanf(float x);
long double atanl(long double x);

==============================================================================
Description

2

The atan functions compute the principal value of the arc tangent of x.

238

Library

§7.12.4.3

N1570




==============================================================================
Returns
3

The atan functions return arctan x in the interval [−π /2, +π /2] radians.

7.12.4.4 The atan2 functions

==============================================================================
Synopsis
1

#include <math.h>
double atan2(double y, double x);
float atan2f(float y, float x);
long double atan2l(long double y, long double x);

==============================================================================
Description

2

The atan2 functions compute the value of the arc tangent of y/x, using the signs of both
arguments to determine the quadrant of the return value. A domain error may occur if
both arguments are zero.

==============================================================================
Returns

3

The atan2 functions return arctan y/x in the interval [−π , +π ] radians.

7.12.4.5 The cos functions

==============================================================================
Synopsis
1

#include <math.h>
double cos(double x);
float cosf(float x);
long double cosl(long double x);

==============================================================================
Description

2

The cos functions compute the cosine of x (measured in radians).

==============================================================================
Returns

3

The cos functions return cos x.

7.12.4.6 The sin functions

==============================================================================
Synopsis
1

#include <math.h>
double sin(double x);
float sinf(float x);
long double sinl(long double x);

==============================================================================
Description

2

The sin functions compute the sine of x (measured in radians).

§7.12.4.6

Library

239

ISO/IEC 9899:201x


N1570


==============================================================================
Returns
3

The sin functions return sin x.

7.12.4.7 The tan functions

==============================================================================
Synopsis
1

#include <math.h>
double tan(double x);
float tanf(float x);
long double tanl(long double x);

==============================================================================
Description

2

The tan functions return the tangent of x (measured in radians).

==============================================================================
Returns

3

The tan functions return tan x.

7.12.5 Hyperbolic functions
7.12.5.1 The acosh functions

==============================================================================
Synopsis
1

#include <math.h>
double acosh(double x);
float acoshf(float x);
long double acoshl(long double x);

==============================================================================
Description

2

The acosh functions compute the (nonnegative) arc hyperbolic cosine of x. A domain
error occurs for arguments less than 1.

==============================================================================
Returns

3

The acosh functions return arcosh x in the interval [0, +∞].

7.12.5.2 The asinh functions

==============================================================================
Synopsis
1

#include <math.h>
double asinh(double x);
float asinhf(float x);
long double asinhl(long double x);

==============================================================================
Description

2

The asinh functions compute the arc hyperbolic sine of x.

240

Library

§7.12.5.2

N1570




==============================================================================
Returns
3

The asinh functions return arsinh x.

7.12.5.3 The atanh functions

==============================================================================
Synopsis
1

#include <math.h>
double atanh(double x);
float atanhf(float x);
long double atanhl(long double x);

==============================================================================
Description

2

The atanh functions compute the arc hyperbolic tangent of x. A domain error occurs
for arguments not in the interval [−1, +1]. A pole error may occur if the argument equals
−1 or +1.

==============================================================================
Returns

3

The atanh functions return artanh x.

7.12.5.4 The cosh functions

==============================================================================
Synopsis
1

#include <math.h>
double cosh(double x);
float coshf(float x);
long double coshl(long double x);

==============================================================================
Description

2

The cosh functions compute the hyperbolic cosine of x. A range error occurs if the
magnitude of x is too large.

==============================================================================
Returns

3

The cosh functions return cosh x.

7.12.5.5 The sinh functions

==============================================================================
Synopsis
1

#include <math.h>
double sinh(double x);
float sinhf(float x);
long double sinhl(long double x);

==============================================================================
Description

2

The sinh functions compute the hyperbolic sine of x. A range error occurs if the
magnitude of x is too large.
§7.12.5.5

Library

241

ISO/IEC 9899:201x


N1570


==============================================================================
Returns
3

The sinh functions return sinh x.

7.12.5.6 The tanh functions

==============================================================================
Synopsis
1

#include <math.h>
double tanh(double x);
float tanhf(float x);
long double tanhl(long double x);

==============================================================================
Description

2

The tanh functions compute the hyperbolic tangent of x.

==============================================================================
Returns

3

The tanh functions return tanh x.

7.12.6 Exponential and logarithmic functions
7.12.6.1 The exp functions

==============================================================================
Synopsis
1

#include <math.h>
double exp(double x);
float expf(float x);
long double expl(long double x);

==============================================================================
Description

2

The exp functions compute the base-e exponential of x. A range error occurs if the
magnitude of x is too large.

==============================================================================
Returns

3

The exp functions return ex .

7.12.6.2 The exp2 functions

==============================================================================
Synopsis
1

#include <math.h>
double exp2(double x);
float exp2f(float x);
long double exp2l(long double x);

==============================================================================
Description

2

The exp2 functions compute the base-2 exponential of x. A range error occurs if the
magnitude of x is too large.
242

Library

§7.12.6.2

N1570




==============================================================================
Returns
3

The exp2 functions return 2x .

7.12.6.3 The expm1 functions

==============================================================================
Synopsis
1

#include <math.h>
double expm1(double x);
float expm1f(float x);
long double expm1l(long double x);

==============================================================================
Description

2

The expm1 functions compute the base-e exponential of the argument, minus 1. A range
error occurs if x is too large.237)

==============================================================================
Returns

3

The expm1 functions return ex − 1.

7.12.6.4 The frexp functions

==============================================================================
Synopsis
1

#include <math.h>
double frexp(double value, int *exp);
float frexpf(float value, int *exp);
long double frexpl(long double value, int *exp);

==============================================================================
Description

2

The frexp functions break a floating-point number into a normalized fraction and an
integral power of 2. They store the integer in the int object pointed to by exp.

==============================================================================
Returns

3

If value is not a floating-point number or if the integral power of 2 is outside the range
of int, the results are unspecified. Otherwise, the frexp functions return the value x,
such that x has a magnitude in the interval [1/2, 1) or zero, and value equals x × 2*exp .
If value is zero, both parts of the result are zero.

237) For small magnitude x, expm1(x) is expected to be more accurate than exp(x) - 1.

§7.12.6.4

Library

243

ISO/IEC 9899:201x


N1570

7.12.6.5 The ilogb functions

==============================================================================
Synopsis
1

#include <math.h>
int ilogb(double x);
int ilogbf(float x);
int ilogbl(long double x);

==============================================================================
Description

2

The ilogb functions extract the exponent of x as a signed int value. If x is zero they
compute the value FP_ILOGB0; if x is infinite they compute the value INT_MAX; if x is
a NaN they compute the value FP_ILOGBNAN; otherwise, they are equivalent to calling
the corresponding logb function and casting the returned value to type int. A domain
error or range error may occur if x is zero, infinite, or NaN. If the correct value is outside
the range of the return type, the numeric result is unspecified.

==============================================================================
Returns

3

The ilogb functions return the exponent of x as a signed int value.
Forward references: the logb functions (7.12.6.11).

7.12.6.6 The ldexp functions

==============================================================================
Synopsis
1

#include <math.h>
double ldexp(double x, int exp);
float ldexpf(float x, int exp);
long double ldexpl(long double x, int exp);

==============================================================================
Description

2

The ldexp functions multiply a floating-point number by an integral power of 2. A
range error may occur.

==============================================================================
Returns

3

The ldexp functions return x × 2exp .

7.12.6.7 The log functions

==============================================================================
Synopsis
1

#include <math.h>
double log(double x);
float logf(float x);
long double logl(long double x);

244

Library

§7.12.6.7

N1570




==============================================================================
Description
2

The log functions compute the base-e (natural) logarithm of x. A domain error occurs if
the argument is negative. A pole error may occur if the argument is zero.

==============================================================================
Returns

3

The log functions return loge x.

7.12.6.8 The log10 functions

==============================================================================
Synopsis
1

#include <math.h>
double log10(double x);
float log10f(float x);
long double log10l(long double x);

==============================================================================
Description

2

The log10 functions compute the base-10 (common) logarithm of x. A domain error
occurs if the argument is negative. A pole error may occur if the argument is zero.

==============================================================================
Returns

3

The log10 functions return log10 x.

7.12.6.9 The log1p functions

==============================================================================
Synopsis
1

#include <math.h>
double log1p(double x);
float log1pf(float x);
long double log1pl(long double x);

==============================================================================
Description

2

The log1p functions compute the base-e (natural) logarithm of 1 plus the argument.238)
A domain error occurs if the argument is less than −1. A pole error may occur if the
argument equals −1.

==============================================================================
Returns

3

The log1p functions return loge (1 + x).

238) For small magnitude x, log1p(x) is expected to be more accurate than log(1 + x).

§7.12.6.9

Library

245

ISO/IEC 9899:201x


N1570

7.12.6.10 The log2 functions

==============================================================================
Synopsis
1

#include <math.h>
double log2(double x);
float log2f(float x);
long double log2l(long double x);

==============================================================================
Description

2

The log2 functions compute the base-2 logarithm of x. A domain error occurs if the
argument is less than zero. A pole error may occur if the argument is zero.

==============================================================================
Returns

3

The log2 functions return log2 x.

7.12.6.11 The logb functions

==============================================================================
Synopsis
1

#include <math.h>
double logb(double x);
float logbf(float x);
long double logbl(long double x);

==============================================================================
Description

2

The logb functions extract the exponent of x, as a signed integer value in floating-point
format. If x is subnormal it is treated as though it were normalized; thus, for positive
finite x,
1 ≤ x × FLT_RADIX−logb(x) < FLT_RADIX
A domain error or pole error may occur if the argument is zero.

==============================================================================
Returns

3

The logb functions return the signed exponent of x.

7.12.6.12 The modf functions

==============================================================================
Synopsis
1

#include <math.h>
double modf(double value, double *iptr);
float modff(float value, float *iptr);
long double modfl(long double value, long double *iptr);

==============================================================================
Description

2

The modf functions break the argument value into integral and fractional parts, each of
which has the same type and sign as the argument. They store the integral part (in
246

Library

§7.12.6.12

N1570



floating-point format) in the object pointed to by iptr.

==============================================================================
Returns
3

The modf functions return the signed fractional part of value.

7.12.6.13 The scalbn and scalbln functions

==============================================================================
Synopsis
1

#include <math.h>
double scalbn(double x, int n);
float scalbnf(float x, int n);
long double scalbnl(long double x, int n);
double scalbln(double x, long int n);
float scalblnf(float x, long int n);
long double scalblnl(long double x, long int n);

==============================================================================
Description

2

The scalbn and scalbln functions compute x × FLT_RADIXn efficiently, not
normally by computing FLT_RADIXn explicitly. A range error may occur.

==============================================================================
Returns

3

The scalbn and scalbln functions return x × FLT_RADIXn .

7.12.7 Power and absolute-value functions
7.12.7.1 The cbrt functions

==============================================================================
Synopsis
1

#include <math.h>
double cbrt(double x);
float cbrtf(float x);
long double cbrtl(long double x);

==============================================================================
Description

2

The cbrt functions compute the real cube root of x.

==============================================================================
Returns

3

The cbrt functions return x1/3 .

§7.12.7.1

Library

247

ISO/IEC 9899:201x


N1570

7.12.7.2 The fabs functions

==============================================================================
Synopsis
1

#include <math.h>
double fabs(double x);
float fabsf(float x);
long double fabsl(long double x);

==============================================================================
Description

2

The fabs functions compute the absolute value of a floating-point number x.

==============================================================================
Returns

3

The fabs functions return | x |.

7.12.7.3 The hypot functions

==============================================================================
Synopsis
1

#include <math.h>
double hypot(double x, double y);
float hypotf(float x, float y);
long double hypotl(long double x, long double y);

==============================================================================
Description

2

The hypot functions compute the square root of the sum of the squares of x and y,
without undue overflow or underflow. A range error may occur.

3


==============================================================================
Returns

4

x2 + y 2 .
The hypot functions return √
⎯⎯⎯⎯⎯⎯

7.12.7.4 The pow functions

==============================================================================
Synopsis
1

#include <math.h>
double pow(double x, double y);
float powf(float x, float y);
long double powl(long double x, long double y);

==============================================================================
Description

2

The pow functions compute x raised to the power y. A domain error occurs if x is finite
and negative and y is finite and not an integer value. A range error may occur. A domain
error may occur if x is zero and y is zero. A domain error or pole error may occur if x is
zero and y is less than zero.

248

Library

§7.12.7.4

N1570




==============================================================================
Returns
3

The pow functions return xy .

7.12.7.5 The sqrt functions

==============================================================================
Synopsis
1

#include <math.h>
double sqrt(double x);
float sqrtf(float x);
long double sqrtl(long double x);

==============================================================================
Description

2

The sqrt functions compute the nonnegative square root of x. A domain error occurs if
the argument is less than zero.

==============================================================================
Returns

3

The sqrt functions return √
⎯⎯x.

7.12.8 Error and gamma functions
7.12.8.1 The erf functions

==============================================================================
Synopsis
1

#include <math.h>
double erf(double x);
float erff(float x);
long double erfl(long double x);

==============================================================================
Description

2

The erf functions compute the error function of x.

==============================================================================
Returns

3

The erf functions return erf x =

2
⎯⎯π
√

∫

x

0

e−t dt.
2

7.12.8.2 The erfc functions

==============================================================================
Synopsis
1

#include <math.h>
double erfc(double x);
float erfcf(float x);
long double erfcl(long double x);

==============================================================================
Description

2

The erfc functions compute the complementary error function of x. A range error
occurs if x is too large.
§7.12.8.2
Library
249

ISO/IEC 9899:201x


N1570


==============================================================================
Returns
3

The erfc functions return erfc x = 1 − erf x =

2
⎯√⎯π

∫

∞

x

e−t dt.
2

7.12.8.3 The lgamma functions

==============================================================================
Synopsis
1

#include <math.h>
double lgamma(double x);
float lgammaf(float x);
long double lgammal(long double x);

==============================================================================
Description

2

The lgamma functions compute the natural logarithm of the absolute value of gamma of
x. A range error occurs if x is too large. A pole error may occur if x is a negative integer
or zero.

==============================================================================
Returns

3

The lgamma functions return loge | Γ(x) |.

7.12.8.4 The tgamma functions

==============================================================================
Synopsis
1

#include <math.h>
double tgamma(double x);
float tgammaf(float x);
long double tgammal(long double x);

==============================================================================
Description

2

The tgamma functions compute the gamma function of x. A domain error or pole error
may occur if x is a negative integer or zero. A range error occurs if the magnitude of x is
too large and may occur if the magnitude of x is too small.

==============================================================================
Returns

3

The tgamma functions return Γ(x).

250

Library

§7.12.8.4

N1570



7.12.9 Nearest integer functions
7.12.9.1 The ceil functions

==============================================================================
Synopsis
1

#include <math.h>
double ceil(double x);
float ceilf(float x);
long double ceill(long double x);

==============================================================================
Description

2

The ceil functions compute the smallest integer value not less than x.

==============================================================================
Returns

3

The ceil functions return ⎡x⎤, expressed as a floating-point number.

7.12.9.2 The floor functions

==============================================================================
Synopsis
1

#include <math.h>
double floor(double x);
float floorf(float x);
long double floorl(long double x);

==============================================================================
Description

2

The floor functions compute the largest integer value not greater than x.

==============================================================================
Returns

3

The floor functions return ⎣x⎦, expressed as a floating-point number.

7.12.9.3 The nearbyint functions

==============================================================================
Synopsis
1

#include <math.h>
double nearbyint(double x);
float nearbyintf(float x);
long double nearbyintl(long double x);

==============================================================================
Description

2

The nearbyint functions round their argument to an integer value in floating-point
format, using the current rounding direction and without raising the ‘‘inexact’’ floatingpoint exception.

§7.12.9.3

Library

251

ISO/IEC 9899:201x


N1570


==============================================================================
Returns
3

The nearbyint functions return the rounded integer value.

7.12.9.4 The rint functions

==============================================================================
Synopsis
1

#include <math.h>
double rint(double x);
float rintf(float x);
long double rintl(long double x);

==============================================================================
Description

2

The rint functions differ from the nearbyint functions (7.12.9.3) only in that the
rint functions may raise the ‘‘inexact’’ floating-point exception if the result differs in
value from the argument.

==============================================================================
Returns

3

The rint functions return the rounded integer value.

7.12.9.5 The lrint and llrint functions

==============================================================================
Synopsis
1

#include <math.h>
long int lrint(double x);
long int lrintf(float x);
long int lrintl(long double x);
long long int llrint(double x);
long long int llrintf(float x);
long long int llrintl(long double x);

==============================================================================
Description

2

The lrint and llrint functions round their argument to the nearest integer value,
rounding according to the current rounding direction. If the rounded value is outside the
range of the return type, the numeric result is unspecified and a domain error or range
error may occur.

==============================================================================
Returns

3

The lrint and llrint functions return the rounded integer value.

252

Library

§7.12.9.5

N1570



7.12.9.6 The round functions

==============================================================================
Synopsis
1

#include <math.h>
double round(double x);
float roundf(float x);
long double roundl(long double x);

==============================================================================
Description

2

The round functions round their argument to the nearest integer value in floating-point
format, rounding halfway cases away from zero, regardless of the current rounding
direction.

==============================================================================
Returns

3

The round functions return the rounded integer value.

7.12.9.7 The lround and llround functions

==============================================================================
Synopsis
1

#include <math.h>
long int lround(double x);
long int lroundf(float x);
long int lroundl(long double x);
long long int llround(double x);
long long int llroundf(float x);
long long int llroundl(long double x);

==============================================================================
Description

2

The lround and llround functions round their argument to the nearest integer value,
rounding halfway cases away from zero, regardless of the current rounding direction. If
the rounded value is outside the range of the return type, the numeric result is unspecified
and a domain error or range error may occur.

==============================================================================
Returns

3

The lround and llround functions return the rounded integer value.

7.12.9.8 The trunc functions

==============================================================================
Synopsis
1

#include <math.h>
double trunc(double x);
float truncf(float x);
long double truncl(long double x);

§7.12.9.8

Library

253

ISO/IEC 9899:201x


N1570


==============================================================================
Description
2

The trunc functions round their argument to the integer value, in floating format,
nearest to but no larger in magnitude than the argument.

==============================================================================
Returns

3

The trunc functions return the truncated integer value.

7.12.10 Remainder functions
7.12.10.1 The fmod functions

==============================================================================
Synopsis
1

#include <math.h>
double fmod(double x, double y);
float fmodf(float x, float y);
long double fmodl(long double x, long double y);

==============================================================================
Description

2

The fmod functions compute the floating-point remainder of x/y.

==============================================================================
Returns

3

The fmod functions return the value x − ny, for some integer n such that, if y is nonzero,
the result has the same sign as x and magnitude less than the magnitude of y. If y is zero,
whether a domain error occurs or the fmod functions return zero is implementationdefined.

7.12.10.2 The remainder functions

==============================================================================
Synopsis
1

#include <math.h>
double remainder(double x, double y);
float remainderf(float x, float y);
long double remainderl(long double x, long double y);

==============================================================================
Description

2

The remainder functions compute the remainder x REM y required by IEC 60559.239)

239) ‘‘When y ≠ 0, the remainder r = x REM y is defined regardless of the rounding mode by the
mathematical relation r = x − ny, where n is the integer nearest the exact value of x/y; whenever
| n − x/y | = 1/2, then n is even. If r = 0, its sign shall be that of x.’’ This definition is applicable for
all implementations.

254

Library

§7.12.10.2

N1570




==============================================================================
Returns
3

The remainder functions return x REM y. If y is zero, whether a domain error occurs
or the functions return zero is implementation defined.

7.12.10.3 The remquo functions

==============================================================================
Synopsis
1

#include <math.h>
double remquo(double x, double y, int *quo);
float remquof(float x, float y, int *quo);
long double remquol(long double x, long double y,
int *quo);

==============================================================================
Description

2

The remquo functions compute the same remainder as the remainder functions. In
the object pointed to by quo they store a value whose sign is the sign of x/y and whose
magnitude is congruent modulo 2n to the magnitude of the integral quotient of x/y, where
n is an implementation-defined integer greater than or equal to 3.

==============================================================================
Returns

3

The remquo functions return x REM y. If y is zero, the value stored in the object
pointed to by quo is unspecified and whether a domain error occurs or the functions
return zero is implementation defined.

7.12.11 Manipulation functions
7.12.11.1 The copysign functions

==============================================================================
Synopsis
1

#include <math.h>
double copysign(double x, double y);
float copysignf(float x, float y);
long double copysignl(long double x, long double y);

==============================================================================
Description

2

The copysign functions produce a value with the magnitude of x and the sign of y.
They produce a NaN (with the sign of y) if x is a NaN. On implementations that
represent a signed zero but do not treat negative zero consistently in arithmetic
operations, the copysign functions regard the sign of zero as positive.

==============================================================================
Returns

3

The copysign functions return a value with the magnitude of x and the sign of y.

§7.12.11.1

Library

255

ISO/IEC 9899:201x


N1570

7.12.11.2 The nan functions

==============================================================================
Synopsis
1

#include <math.h>
double nan(const char *tagp);
float nanf(const char *tagp);
long double nanl(const char *tagp);

==============================================================================
Description

2

The call nan("n-char-sequence") is equivalent to strtod("NAN(n-charsequence)",
(char**)
NULL); the call nan("") is equivalent to
strtod("NAN()", (char**) NULL). If tagp does not point to an n-char
sequence or an empty string, the call is equivalent to strtod("NAN", (char**)
NULL). Calls to nanf and nanl are equivalent to the corresponding calls to strtof
and strtold.

==============================================================================
Returns

3

The nan functions return a quiet NaN, if available, with content indicated through tagp.
If the implementation does not support quiet NaNs, the functions return zero.
Forward references: the strtod, strtof, and strtold functions (7.22.1.3).

7.12.11.3 The nextafter functions

==============================================================================
Synopsis
1

#include <math.h>
double nextafter(double x, double y);
float nextafterf(float x, float y);
long double nextafterl(long double x, long double y);

==============================================================================
Description

2

The nextafter functions determine the next representable value, in the type of the
function, after x in the direction of y, where x and y are first converted to the type of the
function.240) The nextafter functions return y if x equals y. A range error may occur
if the magnitude of x is the largest finite value representable in the type and the result is
infinite or not representable in the type.

==============================================================================
Returns

3

The nextafter functions return the next representable value in the specified format
after x in the direction of y.

240) The argument values are converted to the type of the function, even by a macro implementation of the
function.

256

Library

§7.12.11.3

N1570



7.12.11.4 The nexttoward functions

==============================================================================
Synopsis
1

#include <math.h>
double nexttoward(double x, long double y);
float nexttowardf(float x, long double y);
long double nexttowardl(long double x, long double y);

==============================================================================
Description

2

The nexttoward functions are equivalent to the nextafter functions except that the
second parameter has type long double and the functions return y converted to the
type of the function if x equals y.241)

7.12.12 Maximum, minimum, and positive difference functions
7.12.12.1 The fdim functions

==============================================================================
Synopsis
1

#include <math.h>
double fdim(double x, double y);
float fdimf(float x, float y);
long double fdiml(long double x, long double y);

==============================================================================
Description

2

The fdim functions determine the positive difference between their arguments:
⎧x − y if x > y
⎨
if x ≤ y
⎩+0
A range error may occur.

==============================================================================
Returns

3

The fdim functions return the positive difference value.

7.12.12.2 The fmax functions

==============================================================================
Synopsis
1

#include <math.h>
double fmax(double x, double y);
float fmaxf(float x, float y);
long double fmaxl(long double x, long double y);

241) The result of the nexttoward functions is determined in the type of the function, without loss of
range or precision in a floating second argument.

§7.12.12.2

Library

257

ISO/IEC 9899:201x


N1570


==============================================================================
Description
2

The fmax functions determine the maximum numeric value of their arguments.242)

==============================================================================
Returns

3

The fmax functions return the maximum numeric value of their arguments.

7.12.12.3 The fmin functions

==============================================================================
Synopsis
1

#include <math.h>
double fmin(double x, double y);
float fminf(float x, float y);
long double fminl(long double x, long double y);

==============================================================================
Description

2

The fmin functions determine the minimum numeric value of their arguments.243)

==============================================================================
Returns

3

The fmin functions return the minimum numeric value of their arguments.

7.12.13 Floating multiply-add
7.12.13.1 The fma functions

==============================================================================
Synopsis
1

#include <math.h>
double fma(double x, double y, double z);
float fmaf(float x, float y, float z);
long double fmal(long double x, long double y,
long double z);

==============================================================================
Description

2

The fma functions compute (x × y) + z, rounded as one ternary operation: they compute
the value (as if) to infinite precision and round once to the result format, according to the
current rounding mode. A range error may occur.

==============================================================================
Returns

3

The fma functions return (x × y) + z, rounded as one ternary operation.

242) NaN arguments are treated as missing data: if one argument is a NaN and the other numeric, then the
fmax functions choose the numeric value. See F.10.9.2.
243) The fmin functions are analogous to the fmax functions in their treatment of NaNs.

258

Library

§7.12.13.1

N1570



7.12.14 Comparison macros
1

The relational and equality operators support the usual mathematical relationships
between numeric values. For any ordered pair of numeric values exactly one of the
relationships — less, greater, and equal — is true. Relational operators may raise the
‘‘invalid’’ floating-point exception when argument values are NaNs. For a NaN and a
numeric value, or for two NaNs, just the unordered relationship is true.244) The following
subclauses provide macros that are quiet (non floating-point exception raising) versions
of the relational operators, and other comparison macros that facilitate writing efficient
code that accounts for NaNs without suffering the ‘‘invalid’’ floating-point exception. In
the synopses in this subclause, real-floating indicates that the argument shall be an
expression of real floating type245) (both arguments need not have the same type).246)

7.12.14.1 The isgreater macro

==============================================================================
Synopsis
1

#include <math.h>
int isgreater(real-floating x, real-floating y);

==============================================================================
Description

2

The isgreater macro determines whether its first argument is greater than its second
argument. The value of isgreater(x, y) is always equal to (x) > (y); however,
unlike (x) > (y), isgreater(x, y) does not raise the ‘‘invalid’’ floating-point
exception when x and y are unordered.

==============================================================================
Returns

3

The isgreater macro returns the value of (x) > (y).

7.12.14.2 The isgreaterequal macro

==============================================================================
Synopsis
1

#include <math.h>
int isgreaterequal(real-floating x, real-floating y);

244) IEC 60559 requires that the built-in relational operators raise the ‘‘invalid’’ floating-point exception if
the operands compare unordered, as an error indicator for programs written without consideration of
NaNs; the result in these cases is false.
245) If any argument is of integer type, or any other type that is not a real floating type, the behavior is
undefined.
246) Whether an argument represented in a format wider than its semantic type is converted to the semantic
type is unspecified.

§7.12.14.2

Library

259

ISO/IEC 9899:201x


N1570


==============================================================================
Description
2

The isgreaterequal macro determines whether its first argument is greater than or
equal to its second argument. The value of isgreaterequal(x, y) is always equal
to (x) >= (y); however, unlike (x) >= (y), isgreaterequal(x, y) does
not raise the ‘‘invalid’’ floating-point exception when x and y are unordered.

==============================================================================
Returns

3

The isgreaterequal macro returns the value of (x) >= (y).

7.12.14.3 The isless macro

==============================================================================
Synopsis
1

#include <math.h>
int isless(real-floating x, real-floating y);

==============================================================================
Description

2

The isless macro determines whether its first argument is less than its second
argument. The value of isless(x, y) is always equal to (x) < (y); however,
unlike (x) < (y), isless(x, y) does not raise the ‘‘invalid’’ floating-point
exception when x and y are unordered.

==============================================================================
Returns

3

The isless macro returns the value of (x) < (y).

7.12.14.4 The islessequal macro

==============================================================================
Synopsis
1

#include <math.h>
int islessequal(real-floating x, real-floating y);

==============================================================================
Description

2

The islessequal macro determines whether its first argument is less than or equal to
its second argument. The value of islessequal(x, y) is always equal to
(x) <= (y); however, unlike (x) <= (y), islessequal(x, y) does not raise
the ‘‘invalid’’ floating-point exception when x and y are unordered.

==============================================================================
Returns

3

The islessequal macro returns the value of (x) <= (y).

260

Library

§7.12.14.4

N1570



7.12.14.5 The islessgreater macro

==============================================================================
Synopsis
1

#include <math.h>
int islessgreater(real-floating x, real-floating y);

==============================================================================
Description

2

The islessgreater macro determines whether its first argument is less than or
greater than its second argument. The islessgreater(x, y) macro is similar to
(x) < (y) || (x) > (y); however, islessgreater(x, y) does not raise
the ‘‘invalid’’ floating-point exception when x and y are unordered (nor does it evaluate x
and y twice).

==============================================================================
Returns

3

The islessgreater macro returns the value of (x) < (y) || (x) > (y).

7.12.14.6 The isunordered macro

==============================================================================
Synopsis
1

#include <math.h>
int isunordered(real-floating x, real-floating y);

==============================================================================
Description

2

The isunordered macro determines whether its arguments are unordered.

==============================================================================
Returns

3

The isunordered macro returns 1 if its arguments are unordered and 0 otherwise.

§7.12.14.6

Library

261

ISO/IEC 9899:201x


N1570

7.13 Nonlocal jumps <setjmp.h>
1

The header <setjmp.h> defines the macro setjmp, and declares one function and
one type, for bypassing the normal function call and return discipline.247)

2

The type declared is
jmp_buf
which is an array type suitable for holding the information needed to restore a calling
environment. The environment of a call to the setjmp macro consists of information
sufficient for a call to the longjmp function to return execution to the correct block and
invocation of that block, were it called recursively. It does not include the state of the
floating-point status flags, of open files, or of any other component of the abstract
machine.

3

It is unspecified whether setjmp is a macro or an identifier declared with external
linkage. If a macro definition is suppressed in order to access an actual function, or a
program defines an external identifier with the name setjmp, the behavior is undefined.

7.13.1 Save calling environment
7.13.1.1 The setjmp macro

==============================================================================
Synopsis
1

#include <setjmp.h>
int setjmp(jmp_buf env);

==============================================================================
Description

2

The setjmp macro saves its calling environment in its jmp_buf argument for later use
by the longjmp function.

==============================================================================
Returns

3

If the return is from a direct invocation, the setjmp macro returns the value zero. If the
return is from a call to the longjmp function, the setjmp macro returns a nonzero
value.
Environmental limits

4

An invocation of the setjmp macro shall appear only in one of the following contexts:
— the entire controlling expression of a selection or iteration statement;
— one operand of a relational or equality operator with the other operand an integer
constant expression, with the resulting expression being the entire controlling
247) These functions are useful for dealing with unusual conditions encountered in a low-level function of
a program.

262

Library

§7.13.1.1

N1570



expression of a selection or iteration statement;
— the operand of a unary ! operator with the resulting expression being the entire
controlling expression of a selection or iteration statement; or
— the entire expression of an expression statement (possibly cast to void).
5

If the invocation appears in any other context, the behavior is undefined.

7.13.2 Restore calling environment


vim:tw=78:ts=8:ft=help:norl: